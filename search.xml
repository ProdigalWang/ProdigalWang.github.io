<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android面试常见问题(不定期更新)]]></title>
      <url>%2F2017%2F04%2F14%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[公共部分 谈谈对面向对象的理解 面向对象的设计原则 谈谈常见的设计模式 对于实现设计模式增加的代码量的看法 抽象类、接口的区别 重载、重写的区别 多线程操作静态变量，线程安全问题 Java集合框架 写冒泡排序等算法 什么时候finally代码块不执行 谈谈TCP/IP体系，http、https协议 tcp、udp、socket Android 谈谈handler的实现机制 非UI线程使用问题我们会避免死循环，会什么looper中使用死循环 谈谈service使用 如果我们在service中不开子线程进行长耗时操作会出现什么情况为什么出现ANR 广播的使用 MVP、MVC 谈谈对MVP的理解及使用，优缺点谈谈MVP、MVC的不同业务逻辑应该放在MVP中哪一层 线程池的使用 使用侧重不同，优劣势在哪 fragment生命周期，使用问题 是否遭遇过内存泄漏，如何解决的 动画的分类及各种特点区别 Android性能优化 listview使用问题图片优化缓存策略 热修复 Android存储数据的形式，优劣 谈谈图片三级缓存 LRUCache算法的实现原理 Android事件分发机制 你是如何处理事件冲突的 Android适配问题 OOM，如何避免 混合开发了解吗 数据库 写sql语句 觉得自己sql这方面如何 其他不定期更新 github一个不错的复习库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Github+Hexo轻松搭建个人博客]]></title>
      <url>%2F2017%2F03%2F27%2FHexo-Github%2F</url>
      <content type="text"><![CDATA[准备工作需求 申请一个域名，搭建一个博客站点。别人可以通过该域名访问我们发布的博客等 不需要我们维护服务器，我们只需要关注发布内容，极大降低技术要求 PS:如果我没编程基础怎么办呀？不要慌，按照步骤来耐心点都可以完成的。 分析Github：github提供gh-pages服务是免费的，可以为我们提供存储服务Hexo : 一个快速,简单且功能强大的博客框架,帮助我们快速简单的搭建个人博客MarkDown :是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式 技能提高 html+css+javascript git基本语法 markdown语法 node.js 软件安装 以下为windows环境，其他环境安装软件、命令自行查询。已安装过的用户略过。 下载安装Git 下载安装Node.js 安装Hexo 在安装git后，在任意位置点击鼠标右键，选择Git bash（我在D盘下新建Hexo文件夹后并点击鼠标右键操作）安装hexo npm install -g hexo创建hexo文件夹 hexo init安装依赖包 npm install启动hexo并测试 hexo server 启动之后，打开浏览器，在地址栏输入：http://localhost:4000，你会看到Hexo的示例页面。 各种账号申请 已有的请直接跳过，我们将申请的各平台账号有： Github，博客托管 网易云跟帖 ，博客的评论系统 百度统计，域名的访问统计 LeanCloud，统计文章阅读量 GitHub申请注册输入账号、邮箱、密码,然后点击注册按钮. 创建页面仓库这个仓库的名字需要和你的账号对应，格式: yourname.github.io输入基本信息，然后点击创建仓库.注意命名规则：你的github账号.github.io 查看SSHSSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进入.ssh 目录下，命令行：ls 查看，如果返回：something 和 something.pub ，说明已经有SSH 公钥。 生成SSH密钥没有的话，生成，还是在.ssh目录下，命令行：ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。 在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。 在GitHub上添加SSH密钥打开id_rsa.pub，复制全文。https://github.com/settings/ssh ，Add SSH key，粘贴进去。 其他平台账号到后面在使用 Hexo初体验 使用next主题，强烈推荐按照官方文档操作，能完成你大部分的需求http://theme-next.iissnan.com/getting-started.html 目录结构├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 全局配置 _config.yml # Hexo Configuration # Docs: http://hexo.io/docs/configuration.html # Source: https://github.com/hexojs/hexo/ # Site #站点信息 title: #标题 subtitle: #副标题 description: #站点描述，给搜索引擎看的 author: #作者 email: #电子邮箱 language: zh-Hans #语言 # URL #链接格式 url: #网址 root: / #根目录 permalink: :year/:month/:day/:title/ #文章的链接格式 tag_dir: tags #标签目录 archive_dir: archives #存档目录 category_dir: categories #分类目录 code_dir: downloads/code permalink_defaults: # Directory #目录 source_dir: source #源文件目录 public_dir: public #生成的网页文件目录 # Writing #写作 new_post_name: :title.md #新文章标题 default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿） titlecase: false #标题转换成大写 external_link: true #在新选项卡中打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false highlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace: # Category &amp; Tag #分类和标签 default_category: uncategorized #默认分类 category_map: tag_map: # Archives 2: 开启分页 1: 禁用分页 0: 全部禁用 archive: 2 category: 2 tag: 2 # Server #本地服务器 port: 4000 #端口号 server_ip: localhost #IP 地址 logger: false logger_format: dev # Date / Time format #日期时间格式 date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/ time_format: H:mm:ss # Pagination #分页 per_page: 10 #每页文章数，设置成 0 禁用分页 pagination_dir: page # Disqus #Disqus评论 disqus_shortname: # Extensions #拓展插件 theme: landscape-plus #主题 exclude_generator: plugins: #插件，例如生成 RSS 和站点地图的 - hexo-generator-feed - hexo-generator-sitemap # Deployment #部署，将 lmintlcx 改成用户名 deploy: type: git repo: 刚刚github创库地址.git branch: master 发布博客 新建MarkDown 文件放在hexo\source_posts 下 常用的命令有 hexo help #查看帮助 hexo init #初始化一个目录 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成网页，可以在 public 目录查看整个网站的文件 hexo server #本地预览，&apos;Ctrl+C&apos;关闭 hexo deploy #部署.deploy目录 hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 本机查看,浏览器输入http://localhost:4000 查看你写的文章 hexo clean hexo g hexo s 推送至GitHub，先安装git插件npm install hexo-deployer-git --save hexo clean hexo g hexo d 申请域名并绑定GitHub pages 我用的腾讯学生用户送的.cn域名，可以去godaddy购买，可以使用支付宝，具体可以百度。 以腾讯.cn域名示例，假设你已完成域名购买。 首先我们需要知道自己github pages的IP。电脑打开cmd ping yourname.github.io 你就可以看到ip了。 然后在腾讯云的域名管理中设置域名的解析服务，添加记录。一个A类型，一个CNAME类型 完成绑定方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如prodigalwang.cn方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如prodigalwang.cn 提交更新，这样我们就可以通过域名访问自己的博客了 网易云跟帖注册完成后，获取通用代码 把next主题中的gentie_productKey 后填入productKey的值即可，其他不需要修改。 参考资料 NexT 手把手教你建github技术博客by hexo HEXO搭建个人博客 为NexT主题添加文章阅读量统计功能 Hexo-NexT搭建个人博客（三） 如何搭建一个独立博客——简明Github Pages与Hexo教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android模拟登陆校园教务系统]]></title>
      <url>%2F2017%2F03%2F12%2FAndroid-Login-SchoolEt%2F</url>
      <content type="text"><![CDATA[准备 使用到的开源库有：OkHttputils,JSoup,material-dialogs 思路：post方式发送学号，密码，验证码到教务系统，持久化cookie，利用Jsoup解析返回的html,通过特定的标签内容，确定是否登陆成功。每个校园教务系统登陆可能不一样。 查看教务登录所需信息 浏览器进入教务网址，F12可以打开开发者工具，查询html源码 我们可以先在浏览器上进行登录，查看请求头中需要发送的数据，谷歌浏览器在NetWork—&gt;Headers中查看详细的请求信息 可以看到，FormData中：WebUserNO指学号参数，Password指密码，Agnomen指验证码，其他两个是非必要参数。这时在浏览器上进行登录操作后，可以看一下服务器返回的信息，以进行下一步的解析操作.在NetWork—&gt;Response可以看到服务器返回的html源码。 登录成功返回的例子： 登录失败的例子： 可以看到：在登录成功时，我们可以通过Jsoup判断 第一个table下的第一个td标签下是否为“您好!欢迎您登录教务处网络平台”，来验证用户是否输入了正确的学号，密码和验证码。而在登录失败时，则会弹出一个提示框提示错误信息，我们可以通过Jsoup解析到&lt;\script>标签，判断错误的类型，这样就可以区分是学号还是密码或是验证码输入错误（不同的教务系统的反馈信息不同，自行修改） Jsoup中文文档 代码示例 Application中配置okhttp的cookie保存方式 //okhttp持久化cookies配置,保存到内存中，退出销毁--PersistentCookieStore保存到本地 CookieJarImpl cookieJar = new CookieJarImpl(new MemoryCookieStore()); OkHttpClient okHttpClient = new OkHttpClient.Builder() .cookieJar(cookieJar) .connectTimeout(time, TimeUnit.MILLISECONDS) .readTimeout(time, TimeUnit.MILLISECONDS) .build(); OkHttpUtils.initClient(okHttpClient); 在进入登录页时先去请求图片验证码 /** * 这里用okhttp请求图片验证码是为了保存下cookie */ @Override public void requestRexPic() { if (NetUtil.isConnected()) { this.showProgress(&quot;正在获取验证码...&quot;); OkHttpUtils.get().url(Urls.SCHOOL_GET_REGPIC).build().execute(new BitmapCallback() { @Override public void onError(Call call, Exception e, int id) { hideProgress(); } @Override public void onResponse(Bitmap response, int id) { hideProgress(); ivReg.setImageBitmap(response); } }); } else { this.showFailMsg(&quot;当前无网络&quot;); } } 拼装请求头，发送登录请求。解析返回的html /** * 登录，拼装请求头 * @param stuId 学号 * @param pwd 密码 * @param regNum 验证码 */ @Override public void loginEt(String stuId, String pwd, String regNum) { params = new HashMap&lt;&gt;(); params.put(FORM_DATA_STUID, stuId); params.put(FORM_DATA_PWD, pwd); params.put(FORM_DATA_Agnomen, regNum); if (NetUtil.isConnected()) { iLoginEtView.showProgress(&quot;正在登录,请稍候...&quot;); iLoginEtModel.loginEt(new LoginEtCallback() { @Override public void success() { iLoginEtView.hideProgress(); iLoginEtView.loginSuccess(); } @Override public void fail(String msg) { iLoginEtView.hideProgress(); iLoginEtView.showFailMsg(msg); } }, params); } else { iLoginEtView.showFailMsg(&quot;当前无网络!&quot;); } } /** * JSoup解析服务器返回的信息 * * @param data * @return 登录成功或失败的原因 */ private String checkData(String data) { try { //html转为一个Document对象 Document document = Jsoup.parse(data); //获取table下第一个tr标签 Element tr = document.select(&quot;table&quot;).select(&quot;tr&quot;).first(); //获取tr标签下的第一个td标签 Element td = tr.select(&quot;td&quot;).first(); //信息填写正确登录成功 if (td.text().equals(LOGIN_SUCCESS_INFO)) { return LOGIN_SUCCESS; } else { //获取script标签内的内容 Elements js = document.getElementsByTag(&quot;script&quot;); //最后一组script内容，以 &quot; 分割获取提示的错误信息内容，详细参考校园网址 String[] errorInfo = js.last().data().toString().split(&quot;\&quot;&quot;); if (errorInfo[1].equals(USER_OR_PWD_ERROR_INFO)) { return USER_OR_PWD_ERROR; } else if (errorInfo[1].equals(REGNU_ERROR_INFO)) { return REGNU_ERROR; } return LOGIN_FAIL; } } catch (Exception e) { e.printStackTrace(); } return LOGIN_FAIL; } 到这里，我们就成功登入了教务系统，再拉取课表什么其他的信息的时候，会自动带有cookie，不会出现访问失败的问题。 如果有对这部分源码感兴趣的童鞋，这只是一小部分内容哦，同时也是我的毕业设计。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android使用每日必应美图作为启动页背景图片]]></title>
      <url>%2F2017%2F03%2F06%2FGET-BingImage%2F</url>
      <content type="text"><![CDATA[微软必应每天都会更新一张很美的图片作为网站的背景，拿来做启动页背景也是美美哒。 准备工作 使用的开源库有网络请求:OkHttputils图片加载：Picasso 每日必应图片数据的获取，访问这个网址就可以获取到每日的json数据。http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1 { &quot;images&quot;: [ { &quot;startdate&quot;: &quot;20170305&quot;, &quot;fullstartdate&quot;: &quot;201703051600&quot;, &quot;enddate&quot;: &quot;20170306&quot;, &quot;url&quot;: &quot;/az/hprichbg/rb/SteepSheep_ZH-CN8716398488_1920x1080.jpg&quot;, &quot;urlbase&quot;: &quot;/az/hprichbg/rb/SteepSheep_ZH-CN8716398488&quot;, &quot;copyright&quot;: &quot;瓦莱黑鼻羊，瑞士瓦莱州 (© Alessandra Meniconzi/Solent News/REX/Shutterstock)&quot;, &quot;copyrightlink&quot;: &quot;http://www.bing.com/search?q=%E9%BB%91%E9%BC%BB%E7%BE%8A&amp;form=hpcapt&amp;mkt=zh-cn&quot;, &quot;quiz&quot;: &quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20170305_SteepSheep%22&amp;FORM=HPQUIZ&quot;, &quot;wp&quot;: true, &quot;hsh&quot;: &quot;c737af458c5e07aa3fc472220d828ec9&quot;, &quot;drk&quot;: 1, &quot;top&quot;: 1, &quot;bot&quot;: 1, &quot;hs&quot;: [] } ], &quot;tooltips&quot;: { &quot;loading&quot;: &quot;正在加载...&quot;, &quot;previous&quot;: &quot;上一个图像&quot;, &quot;next&quot;: &quot;下一个图像&quot;, &quot;walle&quot;: &quot;此图片不能下载用作壁纸。&quot;, &quot;walls&quot;: &quot;下载今日美图。仅限用作桌面壁纸。&quot; } } 可以比较清楚的看到，images标签下的url正式图片的请求的地址，利用JsonObject可以轻松提取到数据。可以看到图片分辨率为1920x1080的，满足了大部分的需求。 解析数据/** * 解析json数据 * @param data * @return */ private String resolveData(String data) { String url = &quot;&quot;; try { JSONArray jsonArray = new JSONObject(data).getJSONArray(&quot;images&quot;); for (int i = 0; i &lt; jsonArray.length(); i++) { JSONObject jsonObject = (JSONObject) jsonArray.get(i); if (jsonObject.has(&quot;url&quot;)) { url = jsonObject.getString(&quot;url&quot;); } } } catch (JSONException e) { e.printStackTrace(); } return url; } 示例工程使用MVP框架模式，这里不做介绍。V层，新建StartActivity，实现IStartView接口。P层，负责倒计时，逻辑控制M层，请求数据，解析数据 几处关键的方法：P层计时： /** * 倒计时 * * @param time 隔几秒进入主界面 */ private void countDown(int time) { Timer timer = new Timer(true); TimerTask timerTask = new TimerTask() { @Override public void run() { iStartModel.cancelRequest(); iStartView.goMainActivity(); } }; //time秒之后执行取消请求数据操作，跳转到主界面 timer.schedule(timerTask, time); } @Override public void getData() { if (NetUtil.isConnected()) { countDown(3500); iStartModel.requsetData(new LocalImageCallback() { @Override public void success(String url) { iStartView.showStartInfo(url); } @Override public void fail(String msg) { } }); } else { //当前无网络，可以提示用户打开设置，或者直接进入主界面。 countDown(1000); } } 对源码感兴趣的请访问，同时也是我的毕业设计开源作业：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[修改MySql编码集为UTF-8]]></title>
      <url>%2F2016%2F12%2F06%2FMySql-UTF8%2F</url>
      <content type="text"><![CDATA[乱码问题 在日常撸码过程中，我们可能遭遇到乱码问题，总的来说就是编码与解码不统一导致的。 示例下面以Windows下配置Mysql5.5设置，使其默认编码值为utf-8（在初次安装过程中，自定义设置中有一项选择可以设置默认编码集为utf-8，如果选择了utf-8,那就不需要在设置了） 假如现在已经安装完成，我们可以在控制台输入以下命令查看当前默认的编码集 show variables like &apos;character%&apos;; show variables like &apos;collation_%&apos;; 当然我这是已经完成设置的截图，默认是采用latin1 编码的。 手动设置很简单，直接修改配置文件。在Mysql安装目录下，找到my.ini文件 [client] port=3306 default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] default-character-set=utf8 有的则修改，没有的则添加。重启Mysql服务生效 win+R : net stop mysql net start mysql 再运行查看字符集编码的命令，就会是utf-8的了，一劳永逸。在Linux系统下则修改 my.cnf文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小试Android中使用MVC框架模式]]></title>
      <url>%2F2016%2F10%2F28%2FAndroid-MVC%2F</url>
      <content type="text"><![CDATA[MVC简介 MVC（Model-View-Controller 模型-视图-控制器） Model（模型）直接操作数据层（如数据库记录的读写等），通常有最重的处理任务 View（视图） 直接面向用户数据展示界面，接受用户的数据输入并传递给控制层 Controller（控制器）业务逻辑处理层，本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据 那么，MVC各层与Android又有什么对应关系呢？ Model：负责数据处理相关的逻辑，通知View改变，会常涉及到网络请求及Android中的datebase、SharePreference等。 View：自定义View或ViewGroup，负责将用户的请求通知Controller，并根据model更新界面； Controller：接收用户请求并更新model； 下面以一个简单的登录demo示例 其中，bean中User为实体类，包括用户名和密码；callback作为回调接口在控制层和模型层传递数据处理结果；db为帮助我们在数据库建立一个用户，并提供查询； public class User { private String name; private String pwd; public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } public String getName() { return name; } public void setName(String name) { this.name = name; } public interface LoginCallBack { void success(User user); void fail(int status); } public class MyDataBaseHelper extends SQLiteOpenHelper { private static final String CREATE_LOGIN = &quot;create table LoginInfo(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;name text,&quot; + &quot;password text)&quot;; public MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_LOGIN); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } public void initData(SQLiteDatabase db) { String sql = &quot;insert into LoginInfo(name,password) values(&apos;test&apos;,&apos;test&apos;)&quot;; db.execSQL(sql); } public int queryData( User user) { String sql = &quot;select * from LoginInfo where name=?&quot;; Cursor cursor = this.getReadableDatabase().rawQuery(sql, new String[]{user.getName()}); try{ if (cursor.moveToFirst()) { if (cursor.getString(cursor.getColumnIndex(&quot;password&quot;)).equals(user.getPwd())) { return 1;//正确 } else { return 0;//密码错误 } } return -1;//用户名错误(没有当前用户) }catch (Exception e){ e.printStackTrace(); }finally { cursor.close(); } return -2;//发生错误 } 先从View层讲起：自定义一个LoginView继承自LinearLayout &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;prodigalwang.androidframe.mvc.view.LoginView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/activity_login_mvc&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;EditText android:id=&quot;@+id/et_name_mvc&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:hint=&quot;请输入用户名&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_pwd_mvc&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:hint=&quot;请输入密码&quot; android:inputType=&quot;textPassword&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_login_mvc&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;20dp&quot; android:text=&quot;登录&quot; /&gt; &lt;/prodigalwang.androidframe.mvc.view.LoginView&gt; 通常我们直接在activity中直接初始化各种控件，而我们这样做之后只不过是将布局的初始化化代码移入到自定义的view中。 /** 2 * Author：ProdigalWang 3 * Time: 2016/9/26 4 * 视图层,直接展示给用户。通过视图层将数据请求传送到控制层(Controller) 5 * 作为视图层来说,它只是作为接受用户数据和展示数据的方式 6 */ 7 public class LoginView extends LinearLayout { 8 9 private Context mContext; 10 private EditText mUsername; 11 private EditText mPassword; 12 private Button mLoginBtn; 13 14 public LoginView(Context context, AttributeSet attrs) { 15 super(context, attrs); 16 mContext = context; 17 } 18 19 public void initView() { 20 mUsername = (EditText) findViewById(R.id.et_name_mvc); 21 mPassword = (EditText) findViewById(R.id.et_pwd_mvc); 22 mLoginBtn = (Button) findViewById(R.id.bt_login_mvc); 23 } 24 25 public String getName() { 26 return mUsername.getText().toString(); 27 } 28 29 public String getPwd() { 30 return mPassword.getText().toString(); 31 } 32 33 public void setOnclikLister(OnClickListener onclikLister) { 34 mLoginBtn.setOnClickListener(onclikLister); 35 } 36 37 public void userNameEpty() { 38 Toast.makeText(mContext, &quot;用户名不能为空&quot;, Toast.LENGTH_SHORT).show(); 39 } 40 41 public void passWordEpty() { 42 Toast.makeText(mContext, &quot;密码不能为空&quot;, Toast.LENGTH_SHORT).show(); 43 } 44 45 public void userNameError() { 46 Toast.makeText(mContext, &quot;用户名错误&quot;, Toast.LENGTH_SHORT).show(); 47 } 48 49 public void passWordError() { 50 Toast.makeText(mContext, &quot;密码错误&quot;, Toast.LENGTH_SHORT).show(); 51 } 52 53 public void loginSuccess() { 54 Toast.makeText(mContext, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); 55 } 56 57 public void loginFailure() { 58 Toast.makeText(mContext, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); 59 } 60 } 这样我们就完成了View层的抽取。下面实现Model层：首先我们需要先抽取出一个接口，由于我们的需求很简单，只是一个登陆操作，只需要验证用户输入的用户名和密码是否正确，所以我们的抽取的接口中也只有一个login()方法。 /** *模型层———登录接口 */ public interface ILoginModel { void login(String name, String pwd, LoginCallBack loginCallBack); } /** * Author：ProdigalWang * Time: 2016/9/26 * 模型层实现,完成具体的数据操作。 */ public class LoginModelImpl implements ILoginModel { private MyDataBaseHelper myDataBaseHelper; @Override public void login(String name, String pwd, LoginCallBack loginCallBack) { User user=new User(); user.setName(name); user.setPwd(pwd); myDataBaseHelper = new MyDataBaseHelper(MyAppliction.getContext(), &quot;Login.db&quot;, null, 1); int result = myDataBaseHelper.queryData(user); //发出处理结果，用户得到反馈 if (result == 1) { loginCallBack.success(user); } else { loginCallBack.fail(result); } } } 最后，完成Controller： /** * Author：ProdigalWang * Time: 2016/9/26 */ public class LoginController implements View.OnClickListener { private LoginView loginView; private ILoginModel iLoginModel; public LoginController( LoginView loginView){ this.loginView=loginView; iLoginModel=new LoginModelImpl(); } @Override public void onClick(View v) { switch (v.getId()){ case R.id.bt_login_mvc: String username=loginView.getName(); String pwd=loginView.getPwd(); if (TextUtils.isEmpty(username)){ loginView.userNameEpty(); break; } if (TextUtils.isEmpty(pwd)){ loginView.passWordEpty(); break; } //调用模型层去处理具体的请求 iLoginModel.login(username, pwd, new LoginCallBack() { @Override public void success(User user) { loginView.loginSuccess(); } @Override public void fail(int status) { if (status==0){ //模型层完成数据处理后,通知视图层做出相应的改变。用户得到反馈。 loginView.passWordError(); }else if (status==-1){ loginView.userNameError(); }else { loginView.loginFailure(); } } }); break; } } } 那么，我们实现了MVC框架模式后，我们的Activity里的代码又变成怎么样了呢? /** * 此时Activity就变为了承载视图层的容器。 */ public class MvcLoginActivity extends AppCompatActivity { private MyDataBaseHelper myDataBaseHelper; private SQLiteDatabase db; private LoginView loginView; private LoginController loginController; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_mvc_login); //初始化一个本地用户用来模拟登陆。 myDataBaseHelper = new MyDataBaseHelper(this, &quot;Login.db&quot;, null, 1); db = myDataBaseHelper.getWritableDatabase(); //myDataBaseHelper.initData(db); MVC(); } private void MVC(){ //控件初始化和绑定 loginView= (LoginView) findViewById(R.id.activity_login_mvc); loginView.initView(); loginController=new LoginController(loginView);//视图层结合控制层 loginView.setOnclikLister(loginController); } } 没错，这个时候activity里面的代码就是如此的少。关键之处的代码注释写了，这里就不做详细解释了。 流程分析那么，来总结一下整个流程：首先用户打开应用，loginView.initView()调用，显示整个布局。这时候用户输入用户名名和密码后点击登录按钮，Controller层通过View层的getName()和getPwd()获取到用户输入的数据，紧接着Controller层会调用Model的接口中的login()方法，将数据传递给Model层进行具体的处理。当Model完成处理后，会通过LoginCallBack回调处理的结果，并通知View层进行视图的改变，这是用户得到反馈结果。 总结最后，总结一下MVC带来的好处与不足 ：好处： 总所周知，采用各种各种框架模式都是为了实现高内聚低耦合，实现分层能够实现良好的分工合作，各层独立，修改哪一层对其他层的影响都能降低很多。 重用性高，由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。例如，很多数据可能用HTML来表示，但是也有可能用WAP来表示，而这些表示所需要的命令是改变视图层的实现方式，而控制层和模型层无需做任何改变。 维护性高，部署快。不同的开发人员只需要专注于一层的实现。 不足之处： 不适于小型程序，如果我们在小程序上为了实现MVC框架模式而实现的话，会浪费大量不必要的时间和精力。 增加系统结构和实现的复杂性等。 参考资料http://baike.baidu.com/link?url=3hzUtpjpvrAJCJwjQ1OlGZZVU7Ri_7cXK0gZSqZf-IuR7sRpNRruaG6TtpV3tgJNWQ6l4YR4N6pyk99j3TX9Y2aj1yBAb837M2cLMK5J5MUEBCyjzmVOhT_3Q2_HDPMv https://github.com/jpush/jchat-android 源码下载https://github.com/ProdigalWang/MvcAndMvp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯云环境搭建:Centos6.6+jdk1.8+mysql5.1+tomcat7]]></title>
      <url>%2F2016%2F07%2F28%2FCentOS-Tomcat%2F</url>
      <content type="text"><![CDATA[准备 安装Centos6.6 64位版本(其他版本后续安装命令可能不同),具体步骤参照腾讯云官方文档。 本机电脑安装Xshell,Xftp,用于远程连接服务器，方便操作。服务器需开放22端口。 安装JDK1.8 运行以下命令即可： [root@VM_18_245_centos ~]# yum search jdk[root@VM_18_245_centos ~]]# yum -y install java-1.8.0-openjdk*正常显示complete,即安装完成。 由于没有截取过程图，只能展示以下结果了。查看java 版本：[root@VM_18_245_centos ~]# java -versionopenjdk version “1.8.0_71”OpenJDK Runtime Environment (build 1.8.0_71-b15)OpenJDK 64-Bit Server VM (build 25.71-b15, mixed mode) 安装MySql 依次运行命令：yum install mysqlyum install mysql-serveryum install mysql-devel最后提示 Complete! 表示安装成功 设置mysql开机自启动chkconfig –list |grep mysql 数字代码服务器启动级别，off 代表不随机启动mysqld服务，on代表随机启动服务我们需要设置mysqld随机启动，执行下面命令进行设置 chkconfig mysqld on 这样的结果代表正常 chkconfig –list |grep mysql 启动服务，两种均可以/etc/init.d/mysqld startservice mysqld start 修改基本配置，很重要设置用户权限密码，远程连接等可以参考腾讯云论坛的教程。 安装Tomcat 这里我采用的是离线安装，将安装包上传至服务器解压。 官网下载Tomcat,选择tar.gz版本的； 使用Xftp工具连接至自己的服务器（配置过程省 ） 将下载的压缩包上传至自己的服务器，这里我选择上传到了home文件夹下，你也可以选择其他的文件夹 进入home文件夹下 ，解压[root@VM_18_245_centos ~]# cd /home[root@VM_18_245_centos home]# lsapache-tomcat-7.0.70 apache-tomcat-7.0.70.tar.gz[root@VM_18_245_centos home]# tar zxvf apache-tomcat-7.0.70.tar.gz 启动Tomcat 服务[root@VM_18_245_centos ~]# cd /home/apache-tomcat-7.0.70/bin[root@VM_18_245_centos bin] ./startup.sh停止命令[root@VM_18_245_centos bin] ./shutdown.sh tomcat配置修改我们可以直接利用Xftp 进入Tomcat安装目录下的conf的配置文件，也可以通过命令行修改参考资料：http://www.cnblogs.com/xdp-gacl/p/4097608.html当然有些修改需要重启Tomcat.到这里，基本的安装已经完成了 其他一些需要注意的服务器安全组的配置。默认mysql开放3306，tomcat开放8080]]></content>
    </entry>

    
  
  
</search>
