<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ProdigalWang&#39;s Notes</title>
  <subtitle>学习、分享、交流、进步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prodigalwang.cn/"/>
  <updated>2017-04-14T08:31:00.198Z</updated>
  <id>http://prodigalwang.cn/</id>
  
  <author>
    <name>ProdigalWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android面试常见问题(不定期更新)</title>
    <link href="http://prodigalwang.cn/2017/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://prodigalwang.cn/2017/04/14/面试题目/</id>
    <published>2017-04-13T16:00:00.000Z</published>
    <updated>2017-04-14T08:31:00.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公共部分"><a href="#公共部分" class="headerlink" title="公共部分"></a>公共部分</h3><ul>
<li>谈谈对面向对象的理解</li>
<li>面向对象的设计原则</li>
<li><p>谈谈常见的设计模式</p>
<blockquote>
<p>对于实现设计模式增加的代码量的看法</p>
</blockquote>
</li>
<li><p>抽象类、接口的区别</p>
</li>
<li>重载、重写的区别</li>
<li>多线程操作静态变量，线程安全问题</li>
<li>Java集合框架</li>
</ul>
<a id="more"></a>
<ul>
<li>写冒泡排序等算法</li>
<li>什么时候finally代码块不执行</li>
<li>谈谈TCP/IP体系，http、https协议</li>
<li>tcp、udp、socket</li>
</ul>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul>
<li><p>谈谈handler的实现机制</p>
<blockquote>
<p>非UI线程使用问题<br>我们会避免死循环，会什么looper中使用死循环</p>
</blockquote>
</li>
<li><p>谈谈service使用</p>
<blockquote>
<p>如果我们在service中不开子线程进行长耗时操作会出现什么情况<br>为什么出现ANR</p>
</blockquote>
</li>
<li><p>广播的使用</p>
</li>
<li><p>MVP、MVC</p>
<blockquote>
<p>谈谈对MVP的理解及使用，优缺点<br>谈谈MVP、MVC的不同<br>业务逻辑应该放在MVP中哪一层</p>
</blockquote>
</li>
<li><p>线程池的使用</p>
<blockquote>
<p>使用侧重不同，优劣势在哪</p>
</blockquote>
</li>
<li><p>fragment生命周期，使用问题</p>
</li>
<li><p>是否遭遇过内存泄漏，如何解决的</p>
</li>
<li><p>动画的分类及各种特点区别</p>
</li>
<li><p>Android性能优化</p>
<blockquote>
<p>listview使用问题<br>图片优化<br>缓存策略</p>
</blockquote>
</li>
<li><p>热修复</p>
</li>
<li><p>Android存储数据的形式，优劣</p>
</li>
<li><p>谈谈图片三级缓存</p>
</li>
<li><blockquote>
<p>LRUCache算法的实现原理</p>
</blockquote>
</li>
<li><p>Android事件分发机制</p>
<blockquote>
<p>你是如何处理事件冲突的</p>
</blockquote>
</li>
<li><p>Android适配问题</p>
</li>
<li><p>OOM，如何避免</p>
</li>
<li><p>混合开发了解吗</p>
</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ol>
<li>写sql语句<blockquote>
<p>觉得自己sql这方面如何</p>
</blockquote>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>不定期更新</p>
<p><a href="https://github.com/GeniusVJR/LearningNotes" target="_blank" rel="external">github一个不错的复习库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;公共部分&quot;&gt;&lt;a href=&quot;#公共部分&quot; class=&quot;headerlink&quot; title=&quot;公共部分&quot;&gt;&lt;/a&gt;公共部分&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;谈谈对面向对象的理解&lt;/li&gt;
&lt;li&gt;面向对象的设计原则&lt;/li&gt;
&lt;li&gt;&lt;p&gt;谈谈常见的设计模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于实现设计模式增加的代码量的看法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;抽象类、接口的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;重载、重写的区别&lt;/li&gt;
&lt;li&gt;多线程操作静态变量，线程安全问题&lt;/li&gt;
&lt;li&gt;Java集合框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="综合" scheme="http://prodigalwang.cn/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="Android" scheme="http://prodigalwang.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>利用Github+Hexo轻松搭建个人博客</title>
    <link href="http://prodigalwang.cn/2017/03/27/Hexo-Github/"/>
    <id>http://prodigalwang.cn/2017/03/27/Hexo-Github/</id>
    <published>2017-03-26T16:00:00.000Z</published>
    <updated>2017-04-05T15:08:32.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ol>
<li>申请一个域名，搭建一个博客站点。别人可以通过该域名访问我们发布的博客等</li>
<li>不需要我们维护服务器，我们只需要关注发布内容，极大降低技术要求</li>
</ol>
<p>PS:如果我没编程基础怎么办呀？<br>不要慌，按照步骤来耐心点都可以完成的。</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><a href="https://github.com/" target="_blank" rel="external">Github</a>：github提供gh-pages服务是免费的，可以为我们提供存储服务<br><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> : 一个快速,简单且功能强大的博客框架,帮助我们快速简单的搭建个人博客<br><a href="http://markdownpad.com/" target="_blank" rel="external">MarkDown</a> :是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式</p>
<h3 id="技能提高"><a href="#技能提高" class="headerlink" title="技能提高"></a>技能提高</h3><ul>
<li>html+css+javascript</li>
<li>git基本语法</li>
<li>markdown语法</li>
<li>node.js</li>
</ul>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><blockquote>
<p>以下为windows环境，其他环境安装软件、命令自行查询。已安装过的用户略过。</p>
</blockquote>
<ol>
<li><p>下载安装<a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git</a></p>
</li>
<li><p>下载安装<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></p>
</li>
<li><p>安装<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">Hexo</a></p>
<p>在安装git后，在任意位置点击鼠标右键，选择Git bash（我在D盘下新建Hexo文件夹后并点击鼠标右键操作）<br>安装hexo <code>npm install -g hexo</code><br>创建hexo文件夹 <code>hexo init</code><br>安装依赖包 <code>npm install</code><br>启动hexo并测试 <code>hexo server</code></p>
</li>
</ol>
<p><strong>启动之后，打开浏览器，在地址栏输入：<a href="http://localhost:4000，你会看到Hexo的示例页面" target="_blank" rel="external">http://localhost:4000，你会看到Hexo的示例页面</a></strong>。</p>
<h2 id="各种账号申请"><a href="#各种账号申请" class="headerlink" title="各种账号申请"></a>各种账号申请</h2><blockquote>
<p>已有的请直接跳过，我们将申请的各平台账号有：</p>
<ol>
<li><a href="https://github.com/" target="_blank" rel="external">Github</a>，博客托管</li>
<li><a href="https://gentie.163.com/info.html" target="_blank" rel="external">网易云跟帖</a> ，博客的评论系统</li>
<li><a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">百度统计</a>，域名的访问统计</li>
<li><a href="https://leancloud.cn/" target="_blank" rel="external">LeanCloud</a>，统计文章阅读量</li>
</ol>
</blockquote>
<h3 id="GitHub申请注册"><a href="#GitHub申请注册" class="headerlink" title="GitHub申请注册"></a>GitHub申请注册</h3><p>输入账号、邮箱、密码,然后点击注册按钮.<br><img src="http://i.imgur.com/ey6gf6S.png" alt=""></p>
<h4 id="创建页面仓库"><a href="#创建页面仓库" class="headerlink" title="创建页面仓库"></a>创建页面仓库</h4><p>这个仓库的名字需要和你的账号对应，格式: yourname.github.io<br>输入基本信息，然后点击创建仓库.<br><img src="http://i.imgur.com/HPcHpPR.png" alt=""><br><img src="http://i.imgur.com/WX2zlkg.png" alt=""><br><strong>注意</strong><br>命名规则：你的github账号.github.io</p>
<h4 id="查看SSH"><a href="#查看SSH" class="headerlink" title="查看SSH"></a>查看SSH</h4><p>SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。<br>进入.ssh 目录下，命令行：<br>ls 查看，如果返回：<br>something 和 something.pub ，说明已经有SSH 公钥。</p>
<h4 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h4><p>没有的话，生成，还是在.ssh目录下，命令行：<br>ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。</p>
<p>在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。</p>
<h4 id="在GitHub上添加SSH密钥"><a href="#在GitHub上添加SSH密钥" class="headerlink" title="在GitHub上添加SSH密钥"></a>在GitHub上添加SSH密钥</h4><p>打开id_rsa.pub，复制全文。<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a> ，Add SSH key，粘贴进去。</p>
<blockquote>
<p>其他平台账号到后面在使用</p>
</blockquote>
<h2 id="Hexo初体验"><a href="#Hexo初体验" class="headerlink" title="Hexo初体验"></a>Hexo初体验</h2><blockquote>
<p><strong>使用next主题，强烈推荐按照官方文档操作，能完成你大部分的需求</strong><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a></p>
</blockquote>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>├── .deploy #需要部署的文件<br>├── node_modules #Hexo插件<br>├── public #生成的静态网页文件<br>├── scaffolds #模板<br>├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里<br>| ├── _drafts #草稿<br>| └── _posts #文章<br>├── themes #主题<br>├── _config.yml #全局配置文件<br>└── package.json</p>
<p>全局配置 _config.yml</p>
<pre><code># Hexo Configuration
# Docs: http://hexo.io/docs/configuration.html
# Source: https://github.com/hexojs/hexo/
# Site #站点信息
title:  #标题
subtitle:  #副标题
description:  #站点描述，给搜索引擎看的
author:  #作者
email:  #电子邮箱
language: zh-Hans #语言
# URL #链接格式
url:  #网址
root: / #根目录
permalink: :year/:month/:day/:title/ #文章的链接格式
tag_dir: tags #标签目录
archive_dir: archives #存档目录
category_dir: categories #分类目录
code_dir: downloads/code
permalink_defaults:
# Directory #目录
source_dir: source #源文件目录
public_dir: public #生成的网页文件目录
# Writing #写作
new_post_name: :title.md #新文章标题
default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）
titlecase: false #标题转换成大写
external_link: true #在新选项卡中打开连接
filename_case: 0
render_drafts: false
post_asset_folder: false
relative_link: false
highlight: #语法高亮
  enable: true #是否启用
  line_number: true #显示行号
  tab_replace:
# Category &amp; Tag #分类和标签
default_category: uncategorized #默认分类
category_map:
tag_map:
# Archives
2: 开启分页
1: 禁用分页
0: 全部禁用
archive: 2
category: 2
tag: 2
# Server #本地服务器
port: 4000 #端口号
server_ip: localhost #IP 地址
logger: false
logger_format: dev
# Date / Time format #日期时间格式
date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/
time_format: H:mm:ss
# Pagination #分页
per_page: 10 #每页文章数，设置成 0 禁用分页
pagination_dir: page
# Disqus #Disqus评论
disqus_shortname:
# Extensions #拓展插件
theme: landscape-plus #主题
exclude_generator:
plugins: #插件，例如生成 RSS 和站点地图的
- hexo-generator-feed
- hexo-generator-sitemap
# Deployment #部署，将 lmintlcx 改成用户名
deploy:
  type: git
  repo: 刚刚github创库地址.git
  branch: master
</code></pre><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><blockquote>
<p>新建MarkDown 文件放在hexo\source_posts 下</p>
</blockquote>
<p>常用的命令有</p>
<pre><code>hexo help #查看帮助
hexo init #初始化一个目录
hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成网页，可以在 public 目录查看整个网站的文件
hexo server #本地预览，&apos;Ctrl+C&apos;关闭
hexo deploy #部署.deploy目录
hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹**
</code></pre><p>本机查看,浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 查看你写的文章</p>
<pre><code>hexo clean
hexo g
hexo s
</code></pre><p>推送至GitHub，先安装git插件<code>npm install hexo-deployer-git --save</code></p>
<pre><code>hexo clean
hexo g
hexo d
</code></pre><h2 id="申请域名并绑定GitHub-pages"><a href="#申请域名并绑定GitHub-pages" class="headerlink" title="申请域名并绑定GitHub pages"></a>申请域名并绑定GitHub pages</h2><blockquote>
<p>我用的腾讯学生用户送的.cn域名，可以去godaddy购买，可以使用支付宝，具体可以百度。</p>
</blockquote>
<h3 id="以腾讯-cn域名示例，假设你已完成域名购买。"><a href="#以腾讯-cn域名示例，假设你已完成域名购买。" class="headerlink" title="以腾讯.cn域名示例，假设你已完成域名购买。"></a>以腾讯.cn域名示例，假设你已完成域名购买。</h3><p>  首先我们需要知道自己github pages的IP。电脑打开cmd<br>  <code>ping yourname.github.io</code>  你就可以看到ip了。</p>
<p> 然后在腾讯云的域名管理中设置域名的解析服务，添加记录。一个A类型，一个CNAME类型<br><img src="http://i.imgur.com/NXR8hzR.png" alt=""></p>
<p><img src="http://i.imgur.com/Af8C2zg.png" alt=""></p>
<h3 id="完成绑定"><a href="#完成绑定" class="headerlink" title="完成绑定"></a>完成绑定</h3><p>方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如prodigalwang.cn<br>方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如prodigalwang.cn</p>
<p><strong>提交更新，这样我们就可以通过域名访问自己的博客了</strong></p>
<h2 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h2><p>注册完成后，获取通用代码<br><img src="http://i.imgur.com/Y5S0yWl.png" alt=""></p>
<p>把next主题中的gentie_productKey 后填入productKey的值即可，其他不需要修改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a></li>
<li><a href="http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/" target="_blank" rel="external">手把手教你建github技术博客by hexo</a></li>
<li><a href="http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">HEXO搭建个人博客</a></li>
<li><a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="external">为NexT主题添加文章阅读量统计功能</a></li>
<li><a href="https://neveryu.github.io/2016/11/11/hexo-next-three/" target="_blank" rel="external">Hexo-NexT搭建个人博客（三）</a></li>
<li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;申请一个域名，搭建一个博客站点。别人可以通过该域名访问我们发布的博客等&lt;/li&gt;
&lt;li&gt;不需要我们维护服务器，我们只需要关注发布内容，极大降低技术要求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS:如果我没编程基础怎么办呀？&lt;br&gt;不要慌，按照步骤来耐心点都可以完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="综合" scheme="http://prodigalwang.cn/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="Hexo" scheme="http://prodigalwang.cn/tags/Hexo/"/>
    
      <category term="Github" scheme="http://prodigalwang.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Android模拟登陆校园教务系统</title>
    <link href="http://prodigalwang.cn/2017/03/12/Android-Login-SchoolEt/"/>
    <id>http://prodigalwang.cn/2017/03/12/Android-Login-SchoolEt/</id>
    <published>2017-03-11T16:00:00.000Z</published>
    <updated>2017-03-27T14:12:06.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>使用到的开源库有：OkHttputils,JSoup,material-dialogs</p>
</blockquote>
<p><strong>思路：post方式发送学号，密码，验证码到教务系统，持久化cookie，利用Jsoup解析返回的html,通过特定的标签内容，确定是否登陆成功。<br>每个校园教务系统登陆可能不一样。</strong></p>
<a id="more"></a>
<h2 id="查看教务登录所需信息"><a href="#查看教务登录所需信息" class="headerlink" title="查看教务登录所需信息"></a>查看教务登录所需信息</h2><blockquote>
<p>浏览器进入教务网址，F12可以打开开发者工具，查询html源码</p>
</blockquote>
<p><img src="http://i.imgur.com/IIezUW8.png" alt=""></p>
<p>我们可以先在浏览器上进行登录，查看请求头中需要发送的数据，谷歌浏览器在<strong>NetWork—&gt;Headers</strong>中查看详细的请求信息</p>
<p><img src="http://i.imgur.com/5V5XfKw.png" alt=""></p>
<p>可以看到，FormData中：WebUserNO指学号参数，Password指密码，Agnomen指验证码，其他两个是非必要参数。<br>这时在浏览器上进行登录操作后，可以看一下服务器返回的信息，以进行下一步的解析操作.在<strong>NetWork—&gt;Response</strong>可以看到服务器返回的html源码。</p>
<blockquote>
<p>登录成功返回的例子：</p>
</blockquote>
<p><img src="http://i.imgur.com/nz1LogG.png" alt=""></p>
<blockquote>
<p>登录失败的例子：</p>
</blockquote>
<p><img src="http://i.imgur.com/7BLmQRm.png" alt=""></p>
<p>可以看到：在登录成功时，我们可以通过Jsoup判断 第一个table下的第一个td标签下是否为<strong>“您好!欢迎您登录教务处网络平台”</strong>，来验证用户是否输入了正确的学号，密码和验证码。<br>而在登录失败时，则会弹出一个提示框提示错误信息，我们可以通过Jsoup解析到&lt;\script>标签，判断错误的类型，这样就可以区分是学号还是密码或是验证码输入错误（不同的教务系统的反馈信息不同，自行修改）</p>
<p><a href="http://www.open-open.com/jsoup/" target="_blank" rel="external">Jsoup中文文档</a></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><blockquote>
<p>Application中配置okhttp的cookie保存方式</p>
</blockquote>
<pre><code>//okhttp持久化cookies配置,保存到内存中，退出销毁--PersistentCookieStore保存到本地
    CookieJarImpl cookieJar = new CookieJarImpl(new MemoryCookieStore());
    OkHttpClient okHttpClient = new OkHttpClient.Builder()
            .cookieJar(cookieJar)
            .connectTimeout(time, TimeUnit.MILLISECONDS)
            .readTimeout(time, TimeUnit.MILLISECONDS)
            .build();
    OkHttpUtils.initClient(okHttpClient);
</code></pre><blockquote>
<p>在进入登录页时先去请求图片验证码</p>
</blockquote>
<pre><code>/**
 * 这里用okhttp请求图片验证码是为了保存下cookie
 */
@Override
public void requestRexPic() {
    if (NetUtil.isConnected()) {

        this.showProgress(&quot;正在获取验证码...&quot;);
        OkHttpUtils.get().url(Urls.SCHOOL_GET_REGPIC).build().execute(new BitmapCallback() {
            @Override
            public void onError(Call call, Exception e, int id) {
                hideProgress();
            }

            @Override
            public void onResponse(Bitmap response, int id) {

                hideProgress();

                ivReg.setImageBitmap(response);

            }
        });
    } else {
        this.showFailMsg(&quot;当前无网络&quot;);
    }

}
</code></pre><blockquote>
<p>拼装请求头，发送登录请求。解析返回的html</p>
</blockquote>
<pre><code>/**
 * 登录，拼装请求头
 * @param stuId 学号
 * @param pwd 密码
 * @param regNum 验证码
 */
@Override
public void loginEt(String stuId, String pwd, String regNum) {
    params = new HashMap&lt;&gt;();
    params.put(FORM_DATA_STUID, stuId);
    params.put(FORM_DATA_PWD, pwd);
    params.put(FORM_DATA_Agnomen, regNum);
    if (NetUtil.isConnected()) {

        iLoginEtView.showProgress(&quot;正在登录,请稍候...&quot;);
        iLoginEtModel.loginEt(new LoginEtCallback() {
            @Override
            public void success() {

                iLoginEtView.hideProgress();
                iLoginEtView.loginSuccess();
            }

            @Override
            public void fail(String msg) {

                iLoginEtView.hideProgress();

                iLoginEtView.showFailMsg(msg);
            }
        }, params);
    } else {

        iLoginEtView.showFailMsg(&quot;当前无网络!&quot;);
    }
}
</code></pre><hr>
<pre><code>/**
 * JSoup解析服务器返回的信息
 *
 * @param data
 * @return 登录成功或失败的原因
 */
private String checkData(String data) {
    try {
        //html转为一个Document对象
        Document document = Jsoup.parse(data);
        //获取table下第一个tr标签
        Element tr = document.select(&quot;table&quot;).select(&quot;tr&quot;).first();
        //获取tr标签下的第一个td标签
        Element td = tr.select(&quot;td&quot;).first();
        //信息填写正确登录成功
        if (td.text().equals(LOGIN_SUCCESS_INFO)) {

            return LOGIN_SUCCESS;
        } else {
            //获取script标签内的内容
            Elements js = document.getElementsByTag(&quot;script&quot;);
            //最后一组script内容，以 &quot; 分割获取提示的错误信息内容，详细参考校园网址
            String[] errorInfo = js.last().data().toString().split(&quot;\&quot;&quot;);

            if (errorInfo[1].equals(USER_OR_PWD_ERROR_INFO)) {
                return USER_OR_PWD_ERROR;
            } else if (errorInfo[1].equals(REGNU_ERROR_INFO)) {
                return REGNU_ERROR;
            }
            return LOGIN_FAIL;

        }
    } catch (Exception e) {
        e.printStackTrace();
    }

    return LOGIN_FAIL;
}
</code></pre><hr>
<p>到这里，我们就成功登入了教务系统，再拉取课表什么其他的信息的时候，会自动带有cookie，不会出现访问失败的问题。</p>
<p>如果有对这部分源码感兴趣的童鞋，这只是一小部分内容哦，同时也是我的<a href="https://github.com/ProdigalWang/NewbornAssistant/tree/master/app/src/main/java/prodigalwang/newbornassistant/educational" target="_blank" rel="external">毕业设计</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用到的开源库有：OkHttputils,JSoup,material-dialogs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;思路：post方式发送学号，密码，验证码到教务系统，持久化cookie，利用Jsoup解析返回的html,通过特定的标签内容，确定是否登陆成功。&lt;br&gt;每个校园教务系统登陆可能不一样。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android开发" scheme="http://prodigalwang.cn/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://prodigalwang.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android使用每日必应美图作为启动页背景图片</title>
    <link href="http://prodigalwang.cn/2017/03/06/GET-BingImage/"/>
    <id>http://prodigalwang.cn/2017/03/06/GET-BingImage/</id>
    <published>2017-03-05T16:00:00.000Z</published>
    <updated>2017-03-27T14:11:56.325Z</updated>
    
    <content type="html"><![CDATA[<p><strong>微软必应每天都会更新一张很美的图片作为网站的背景，拿来做启动页背景也是美美哒。</strong></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote>
<p>使用的开源库有<br>网络请求:OkHttputils<br>图片加载：Picasso</p>
</blockquote>
<a id="more"></a>
<p>每日必应图片数据的获取，访问这个网址就可以获取到每日的json数据。<br><a href="http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1" target="_blank" rel="external">http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a> </p>
<pre><code>{
&quot;images&quot;: [
    {
        &quot;startdate&quot;: &quot;20170305&quot;,
        &quot;fullstartdate&quot;: &quot;201703051600&quot;,
        &quot;enddate&quot;: &quot;20170306&quot;,
        &quot;url&quot;: &quot;/az/hprichbg/rb/SteepSheep_ZH-CN8716398488_1920x1080.jpg&quot;,
        &quot;urlbase&quot;: &quot;/az/hprichbg/rb/SteepSheep_ZH-CN8716398488&quot;,
        &quot;copyright&quot;: &quot;瓦莱黑鼻羊，瑞士瓦莱州 (© Alessandra Meniconzi/Solent News/REX/Shutterstock)&quot;,
        &quot;copyrightlink&quot;: &quot;http://www.bing.com/search?q=%E9%BB%91%E9%BC%BB%E7%BE%8A&amp;form=hpcapt&amp;mkt=zh-cn&quot;,
        &quot;quiz&quot;: &quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20170305_SteepSheep%22&amp;FORM=HPQUIZ&quot;,
        &quot;wp&quot;: true,
        &quot;hsh&quot;: &quot;c737af458c5e07aa3fc472220d828ec9&quot;,
        &quot;drk&quot;: 1,
        &quot;top&quot;: 1,
        &quot;bot&quot;: 1,
        &quot;hs&quot;: []
    }
],
&quot;tooltips&quot;: {
    &quot;loading&quot;: &quot;正在加载...&quot;,
    &quot;previous&quot;: &quot;上一个图像&quot;,
    &quot;next&quot;: &quot;下一个图像&quot;,
    &quot;walle&quot;: &quot;此图片不能下载用作壁纸。&quot;,
    &quot;walls&quot;: &quot;下载今日美图。仅限用作桌面壁纸。&quot;
}
}
</code></pre><p>可以比较清楚的看到，images标签下的url正式图片的请求的地址，利用JsonObject可以轻松提取到数据。可以看到图片分辨率为1920x1080的，满足了大部分的需求。</p>
<h2 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h2><pre><code>/**
 * 解析json数据
 * @param data
 * @return
 */
private String resolveData(String data) {

    String url = &quot;&quot;;
    try {
        JSONArray jsonArray = new JSONObject(data).getJSONArray(&quot;images&quot;);

        for (int i = 0; i &lt; jsonArray.length(); i++) {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);
            if (jsonObject.has(&quot;url&quot;)) {

                url = jsonObject.getString(&quot;url&quot;);
            }
        }

    } catch (JSONException e) {
        e.printStackTrace();
    }

    return url;
}
</code></pre><h2 id="示例工程"><a href="#示例工程" class="headerlink" title="示例工程"></a>示例工程</h2><p><img src="http://i.imgur.com/SNv2Wsx.png" alt=""><br>使用MVP框架模式，这里不做介绍。<br>V层，新建StartActivity，实现IStartView接口。<br>P层，负责倒计时，逻辑控制<br>M层，请求数据，解析数据</p>
<p>几处关键的方法：<br><strong>P层计时：</strong></p>
<pre><code>/**
 * 倒计时
 *
 * @param time 隔几秒进入主界面
 */
private void countDown(int time) {
    Timer timer = new Timer(true);
    TimerTask timerTask = new TimerTask() {
        @Override
        public void run() {

            iStartModel.cancelRequest();
            iStartView.goMainActivity();
        }
    };
    //time秒之后执行取消请求数据操作，跳转到主界面
    timer.schedule(timerTask, time);
}
</code></pre><hr>
<pre><code> @Override
public void getData() {
    if (NetUtil.isConnected()) {

        countDown(3500);

        iStartModel.requsetData(new LocalImageCallback() {
            @Override
            public void success(String url) {
                iStartView.showStartInfo(url);
            }

            @Override
            public void fail(String msg) {

            }
        });
    } else {

        //当前无网络，可以提示用户打开设置，或者直接进入主界面。
        countDown(1000);
    }

}
</code></pre><hr>
<p>对源码感兴趣的请访问，同时也是我的毕业设计<a href="https://github.com/ProdigalWang/NewbornAssistant/tree/master/app/src/main/java/prodigalwang/newbornassistant/start" target="_blank" rel="external">开源</a>作业：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;微软必应每天都会更新一张很美的图片作为网站的背景，拿来做启动页背景也是美美哒。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用的开源库有&lt;br&gt;网络请求:OkHttputils&lt;br&gt;图片加载：Picasso&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android开发" scheme="http://prodigalwang.cn/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://prodigalwang.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>修改MySql编码集为UTF-8</title>
    <link href="http://prodigalwang.cn/2016/12/06/MySql-UTF8/"/>
    <id>http://prodigalwang.cn/2016/12/06/MySql-UTF8/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2017-03-27T14:11:42.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><blockquote>
<p>在日常撸码过程中，我们可能遭遇到乱码问题，总的来说就是编码与解码不统一导致的。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面以Windows下配置Mysql5.5设置，使其默认编码值为utf-8（在初次安装过程中，自定义设置中有一项选择可以设置默认编码集为utf-8，如果选择了utf-8,那就不需要在设置了）</p>
<a id="more"></a>
<p> 假如现在已经安装完成，我们可以在控制台输入以下命令查看当前默认的编码集</p>
<pre><code>show variables like &apos;character%&apos;;
show variables like &apos;collation_%&apos;;
</code></pre><p><img src="http://i.imgur.com/SnqkhiC.png" alt=""></p>
<p><img src="http://i.imgur.com/owFFkCG.png" alt=""></p>
<p>当然我这是已经完成设置的截图，默认是采用latin1 编码的。</p>
<p><strong>手动设置很简单，直接修改配置文件。在Mysql安装目录下，找到my.ini文件</strong></p>
<pre><code>[client]
port=3306
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld]
default-character-set=utf8
</code></pre><p>有的则修改，没有的则添加。<br>重启Mysql服务生效</p>
<pre><code>win+R : net stop mysql
        net start mysql
</code></pre><p>再运行查看字符集编码的命令，就会是utf-8的了，一劳永逸。<br>在Linux系统下则修改 my.cnf文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;乱码问题&quot;&gt;&lt;a href=&quot;#乱码问题&quot; class=&quot;headerlink&quot; title=&quot;乱码问题&quot;&gt;&lt;/a&gt;乱码问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在日常撸码过程中，我们可能遭遇到乱码问题，总的来说就是编码与解码不统一导致的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;下面以Windows下配置Mysql5.5设置，使其默认编码值为utf-8（在初次安装过程中，自定义设置中有一项选择可以设置默认编码集为utf-8，如果选择了utf-8,那就不需要在设置了）&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://prodigalwang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://prodigalwang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>小试Android中使用MVC框架模式</title>
    <link href="http://prodigalwang.cn/2016/10/28/Android-MVC/"/>
    <id>http://prodigalwang.cn/2016/10/28/Android-MVC/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2017-03-26T15:36:37.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h2><p>  <strong>MVC（Model-View-Controller 模型-视图-控制器）</strong></p>
<ol>
<li>Model（模型）直接操作数据层（如数据库记录的读写等），通常有最重的处理任务</li>
<li>View（视图） 直接面向用户数据展示界面，接受用户的数据输入并传递给控制层</li>
<li>Controller（控制器）业务逻辑处理层，本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据</li>
</ol>
<a id="more"></a>
<h2 id="那么，MVC各层与Android又有什么对应关系呢？"><a href="#那么，MVC各层与Android又有什么对应关系呢？" class="headerlink" title="那么，MVC各层与Android又有什么对应关系呢？"></a>那么，MVC各层与Android又有什么对应关系呢？</h2><ol>
<li>Model：负责数据处理相关的逻辑，通知View改变，会常涉及到网络请求及Android中的datebase、SharePreference等。</li>
<li>View：自定义View或ViewGroup，负责将用户的请求通知Controller，并根据model更新界面；　</li>
<li>Controller：接收用户请求并更新model；</li>
</ol>
<h2 id="下面以一个简单的登录demo示例"><a href="#下面以一个简单的登录demo示例" class="headerlink" title="下面以一个简单的登录demo示例"></a>下面以一个简单的登录demo示例</h2><p><img src="http://i.imgur.com/VvdrEGX.png" alt=""></p>
<blockquote>
<p>其中，bean中User为实体类，包括用户名和密码；callback作为回调接口在控制层和模型层传递数据处理结果；db为帮助我们在数据库建立一个用户，并提供查询；</p>
</blockquote>
<pre><code>public class User {

private String name;
private String pwd;

public String getPwd() {
    return pwd;
}

public void setPwd(String pwd) {
    this.pwd = pwd;
}

public String getName() {

    return name;
}

public void setName(String name) {
    this.name = name;
}
</code></pre><hr>
<pre><code>public interface LoginCallBack {
void success(User user);
void fail(int status);
}
</code></pre><hr>
<pre><code>public class MyDataBaseHelper extends SQLiteOpenHelper {


  private static final String CREATE_LOGIN = &quot;create table LoginInfo(&quot; +
          &quot;id integer primary key autoincrement,&quot; +
          &quot;name text,&quot; +
          &quot;password text)&quot;;


 public MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
     super(context, name, factory, version);
 }

 @Override
 public void onCreate(SQLiteDatabase db) {
     db.execSQL(CREATE_LOGIN);
 }

 @Override
 public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

 }

 public void initData(SQLiteDatabase db) {

     String sql = &quot;insert into LoginInfo(name,password) values(&apos;test&apos;,&apos;test&apos;)&quot;;
     db.execSQL(sql);
 }

 public int queryData( User user) {

     String sql = &quot;select * from LoginInfo where name=?&quot;;
     Cursor cursor = this.getReadableDatabase().rawQuery(sql, new String[]{user.getName()});

     try{
         if (cursor.moveToFirst()) {
             if (cursor.getString(cursor.getColumnIndex(&quot;password&quot;)).equals(user.getPwd())) {

                 return 1;//正确
             } else {
                 return 0;//密码错误
             }
         }             return -1;//用户名错误(没有当前用户)
     }catch (Exception e){
         e.printStackTrace();
     }finally {
         cursor.close();
     }
     return -2;//发生错误

 }
</code></pre><blockquote>
<p>先从View层讲起：自定义一个LoginView继承自LinearLayout</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;prodigalwang.androidframe.mvc.view.LoginView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/activity_login_mvc&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot;&gt;

&lt;EditText
    android:id=&quot;@+id/et_name_mvc&quot;
    android:layout_width=&quot;200dp&quot;
    android:layout_height=&quot;40dp&quot;
    android:layout_gravity=&quot;center_horizontal&quot;
    android:hint=&quot;请输入用户名&quot; /&gt;

&lt;EditText
    android:id=&quot;@+id/et_pwd_mvc&quot;
    android:layout_width=&quot;200dp&quot;
    android:layout_height=&quot;40dp&quot;
    android:layout_gravity=&quot;center_horizontal&quot;
    android:hint=&quot;请输入密码&quot;
    android:inputType=&quot;textPassword&quot; /&gt;

&lt;Button
    android:id=&quot;@+id/bt_login_mvc&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_horizontal&quot;
    android:layout_marginTop=&quot;20dp&quot;
    android:text=&quot;登录&quot; /&gt;
&lt;/prodigalwang.androidframe.mvc.view.LoginView&gt;
</code></pre><blockquote>
<p>通常我们直接在activity中直接初始化各种控件，而我们这样做之后只不过是将布局的初始化化代码移入到自定义的view中。</p>
</blockquote>
<pre><code>    /**
2  * Author：ProdigalWang
3  * Time: 2016/9/26
 4  * 视图层,直接展示给用户。通过视图层将数据请求传送到控制层(Controller)
 5  * 作为视图层来说,它只是作为接受用户数据和展示数据的方式
 6  */
 7 public class LoginView extends LinearLayout {
 8 
 9 private Context mContext;
10 private EditText mUsername;
11 private EditText mPassword;
12 private Button mLoginBtn;
13 
14 public LoginView(Context context, AttributeSet attrs) {
15 super(context, attrs);
16 mContext = context;
17 }
18 
19 public void initView() {
20 mUsername = (EditText) findViewById(R.id.et_name_mvc);
21 mPassword = (EditText) findViewById(R.id.et_pwd_mvc);
22 mLoginBtn = (Button) findViewById(R.id.bt_login_mvc);
23 }
24 
25 public String getName() {
26 return mUsername.getText().toString();
27 }
28 
29 public String getPwd() {
30 return mPassword.getText().toString();
31 }
32 
33 public void setOnclikLister(OnClickListener onclikLister) {
34 mLoginBtn.setOnClickListener(onclikLister);
35 }
36 
37 public void userNameEpty() {
38 Toast.makeText(mContext, &quot;用户名不能为空&quot;, Toast.LENGTH_SHORT).show();
39 }
40 
41 public void passWordEpty() {
42 Toast.makeText(mContext, &quot;密码不能为空&quot;, Toast.LENGTH_SHORT).show();
43 }
44 
45 public void userNameError() {
46 Toast.makeText(mContext, &quot;用户名错误&quot;, Toast.LENGTH_SHORT).show();
47 }
48 
49 public void passWordError() {
50 Toast.makeText(mContext, &quot;密码错误&quot;, Toast.LENGTH_SHORT).show();
51 }
52 
53 public void loginSuccess() {
54 Toast.makeText(mContext, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();
55 }
56 
57 public void loginFailure() {
58 Toast.makeText(mContext, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();
59 }
60 }
</code></pre><blockquote>
<p>这样我们就完成了View层的抽取。<br>下面实现Model层：首先我们需要先抽取出一个接口，由于我们的需求很简单，只是一个登陆操作，只需要验证用户输入的用户名和密码是否正确，所以我们的抽取的接口中也只有一个login()方法。</p>
</blockquote>
<pre><code>/**
 *模型层———登录接口
 */

public interface ILoginModel {

void login(String name, String pwd, LoginCallBack loginCallBack);
}
</code></pre><hr>
<pre><code>/**
 * Author：ProdigalWang
 * Time: 2016/9/26
 * 模型层实现,完成具体的数据操作。
 */

public class LoginModelImpl implements ILoginModel {

private MyDataBaseHelper myDataBaseHelper;

@Override
public void login(String name, String pwd, LoginCallBack loginCallBack) {

User user=new User();
user.setName(name);
user.setPwd(pwd);

myDataBaseHelper = new MyDataBaseHelper(MyAppliction.getContext(), &quot;Login.db&quot;, null, 1);

int result = myDataBaseHelper.queryData(user);

//发出处理结果，用户得到反馈
if (result == 1) {

loginCallBack.success(user);
} else {
loginCallBack.fail(result);
}
}
}
</code></pre><blockquote>
<p>最后，完成Controller：</p>
</blockquote>
<pre><code>/**
 * Author：ProdigalWang
 * Time: 2016/9/26
 */
public class LoginController implements View.OnClickListener {

private LoginView loginView;
private ILoginModel iLoginModel;

public LoginController( LoginView loginView){
this.loginView=loginView;

iLoginModel=new LoginModelImpl();
}
@Override
public void onClick(View v) {
switch (v.getId()){
case R.id.bt_login_mvc:
String username=loginView.getName();
String pwd=loginView.getPwd();

if (TextUtils.isEmpty(username)){
loginView.userNameEpty();
break;
}
if (TextUtils.isEmpty(pwd)){
loginView.passWordEpty();
break;
}
//调用模型层去处理具体的请求
iLoginModel.login(username, pwd, new LoginCallBack() {
@Override
public void success(User user) {
loginView.loginSuccess();
}

@Override
public void fail(int status) {
if (status==0){
//模型层完成数据处理后,通知视图层做出相应的改变。用户得到反馈。
loginView.passWordError();
}else if (status==-1){
loginView.userNameError();
}else {
loginView.loginFailure();
}
}

});
break;
}
}
}
</code></pre><blockquote>
<p>那么，我们实现了MVC框架模式后，我们的Activity里的代码又变成怎么样了呢?</p>
</blockquote>
<pre><code>/**
 * 此时Activity就变为了承载视图层的容器。
 */
public class MvcLoginActivity extends AppCompatActivity {

private MyDataBaseHelper myDataBaseHelper;
private SQLiteDatabase db;

private LoginView loginView;
private LoginController loginController;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_mvc_login);

//初始化一个本地用户用来模拟登陆。
myDataBaseHelper = new MyDataBaseHelper(this, &quot;Login.db&quot;, null, 1);
db = myDataBaseHelper.getWritableDatabase();
   //myDataBaseHelper.initData(db);

   MVC();
}

   private void MVC(){
//控件初始化和绑定
loginView= (LoginView) findViewById(R.id.activity_login_mvc);
loginView.initView();

loginController=new LoginController(loginView);//视图层结合控制层
loginView.setOnclikLister(loginController);
}
}
</code></pre><p>没错，这个时候activity里面的代码就是如此的少。关键之处的代码注释写了，这里就不做详细解释了。</p>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>那么，来总结一下整个流程：首先用户打开应用，loginView.initView()调用，显示整个布局。这时候用户输入用户名名和密码后点击登录按钮，Controller层通过View层的getName()和getPwd()获取到用户输入的数据，紧接着Controller层会调用Model的接口中的login()方法，将数据传递给Model层进行具体的处理。当Model完成处理后，会通过LoginCallBack回调处理的结果，并通知View层进行视图的改变，这是用户得到反馈结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，总结一下MVC带来的好处与不足 ：<br><strong>好处：</strong></p>
<ol>
<li>总所周知，采用各种各种框架模式都是为了实现高内聚低耦合，实现分层能够实现良好的分工合作，各层独立，修改哪一层对其他层的影响都能降低很多。</li>
<li>重用性高，由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。例如，很多数据可能用HTML来表示，但是也有可能用WAP来表示，而这些表示所需要的命令是改变视图层的实现方式，而控制层和模型层无需做任何改变。</li>
<li>维护性高，部署快。不同的开发人员只需要专注于一层的实现。</li>
</ol>
<p><strong> 不足之处：</strong></p>
<ol>
<li>不适于小型程序，如果我们在小程序上为了实现MVC框架模式而实现的话，会浪费大量不必要的时间和精力。</li>
<li>增加系统结构和实现的复杂性等。</li>
</ol>
<p><strong>参考资料</strong><br><a href=".http://baike.baidu.com/link?url=3hzUtpjpvrAJCJwjQ1OlGZZVU7Ri_7cXK0gZSqZf-IuR7sRpNRruaG6TtpV3tgJNWQ6l4YR4N6pyk99j3TX9Y2aj1yBAb837M2cLMK5J5MUEBCyjzmVOhT_3Q2_HDPMv" title="百度百科" target="_blank" rel="external">http://baike.baidu.com/link?url=3hzUtpjpvrAJCJwjQ1OlGZZVU7Ri_7cXK0gZSqZf-IuR7sRpNRruaG6TtpV3tgJNWQ6l4YR4N6pyk99j3TX9Y2aj1yBAb837M2cLMK5J5MUEBCyjzmVOhT_3Q2_HDPMv</a></p>
<p><a href="https://github.com/jpush/jchat-android" target="_blank" rel="external">https://github.com/jpush/jchat-android</a></p>
<p><strong>源码下载</strong><br><a href="https://github.com/ProdigalWang/MvcAndMvp" target="_blank" rel="external">https://github.com/ProdigalWang/MvcAndMvp</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVC简介&quot;&gt;&lt;a href=&quot;#MVC简介&quot; class=&quot;headerlink&quot; title=&quot;MVC简介&quot;&gt;&lt;/a&gt;MVC简介&lt;/h2&gt;&lt;p&gt;  &lt;strong&gt;MVC（Model-View-Controller 模型-视图-控制器）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Model（模型）直接操作数据层（如数据库记录的读写等），通常有最重的处理任务&lt;/li&gt;
&lt;li&gt;View（视图） 直接面向用户数据展示界面，接受用户的数据输入并传递给控制层&lt;/li&gt;
&lt;li&gt;Controller（控制器）业务逻辑处理层，本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android开发" scheme="http://prodigalwang.cn/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://prodigalwang.cn/tags/Android/"/>
    
      <category term="MVC" scheme="http://prodigalwang.cn/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云环境搭建:Centos6.6+jdk1.8+mysql5.1+tomcat7</title>
    <link href="http://prodigalwang.cn/2016/07/28/CentOS-Tomcat/"/>
    <id>http://prodigalwang.cn/2016/07/28/CentOS-Tomcat/</id>
    <published>2016-07-27T16:00:00.000Z</published>
    <updated>2017-03-26T15:36:57.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>安装Centos6.6 64位版本(其他版本后续安装命令可能不同),具体步骤参照腾讯云官方文档。</li>
<li>本机电脑安装Xshell,Xftp,用于远程连接服务器，方便操作。服务器需开放22端口。</li>
</ol>
<h2 id="安装JDK1-8"><a href="#安装JDK1-8" class="headerlink" title="安装JDK1.8"></a>安装JDK1.8</h2><blockquote>
<p>运行以下命令即可：</p>
</blockquote>
<p>[root@VM_18_245_centos ~]# yum search jdk<br>[root@VM_18_245_centos ~]]# yum -y install  java-1.8.0-openjdk*<br>正常显示complete,即安装完成。</p>
<a id="more"></a>
<p>由于没有截取过程图，只能展示以下结果了。查看java 版本：<br>[root@VM_18_245_centos ~]# java -version<br>openjdk version “1.8.0_71”<br>OpenJDK Runtime Environment (build 1.8.0_71-b15)<br>OpenJDK 64-Bit Server VM (build 25.71-b15, mixed mode)</p>
<h2 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h2><ol>
<li><p>依次运行命令：<br>yum install mysql<br>yum install mysql-server<br>yum install mysql-devel<br>最后提示 Complete!  表示安装成功</p>
</li>
<li><p>设置mysql开机自启动<br>chkconfig –list |grep mysql<br><img src="http://i.imgur.com/18NFRt3.jpg" alt=""></p>
</li>
</ol>
<p>数字代码服务器启动级别，off  代表不随机启动mysqld服务，on代表随机启动服务<br>我们需要设置mysqld随机启动，执行下面命令进行设置</p>
<p> chkconfig mysqld on </p>
<p>这样的结果代表正常 </p>
<p> chkconfig –list |grep mysql<br><img src="http://i.imgur.com/tQVIEzX.jpg" alt=""></p>
<ol>
<li>启动服务，两种均可以<br>/etc/init.d/mysqld start<br>service mysqld start </li>
<li>修改基本配置，很重要<br>设置用户权限密码，远程连接等可以参考<a href="http://bbs.qcloud.com/thread-5583-1-1.html" target="_blank" rel="external">腾讯云论坛</a>的教程。</li>
</ol>
<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><blockquote>
<p>这里我采用的是离线安装，将安装包上传至服务器解压。</p>
</blockquote>
<ol>
<li>官网下载<a href="http://tomcat.apache.org" target="_blank" rel="external">Tomcat</a>,选择tar.gz版本的；</li>
<li>使用Xftp工具连接至自己的服务器（配置过程省 ）</li>
<li>将下载的压缩包上传至自己的服务器，这里我选择上传到了home文件夹下，你也可以选择其他的文件夹<br><img src="http://i.imgur.com/7dzy0Kx.png" alt=""></li>
<li>进入home文件夹下 ，解压<br>[root@VM_18_245_centos ~]# cd /home<br>[root@VM_18_245_centos home]# ls<br>apache-tomcat-7.0.70 apache-tomcat-7.0.70.tar.gz<br>[root@VM_18_245_centos home]# tar zxvf apache-tomcat-7.0.70.tar.gz</li>
<li>启动Tomcat 服务<br>[root@VM_18_245_centos ~]# cd /home/apache-tomcat-7.0.70/bin<br>[root@VM_18_245_centos bin] ./startup.sh<br>停止命令<br>[root@VM_18_245_centos bin] ./shutdown.sh</li>
<li>tomcat配置修改<br>我们可以直接利用Xftp 进入Tomcat安装目录下的conf的配置文件，也可以通过命令行修改<br>参考资料：<a href="http://www.cnblogs.com/xdp-gacl/p/4097608.html" target="_blank" rel="external">http://www.cnblogs.com/xdp-gacl/p/4097608.html</a><br>当然有些修改需要重启Tomcat.<br>到这里，基本的安装已经完成了</li>
</ol>
<h2 id="其他一些需要注意的"><a href="#其他一些需要注意的" class="headerlink" title="其他一些需要注意的"></a>其他一些需要注意的</h2><p>服务器安全组的配置。默认mysql开放3306，tomcat开放8080</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装Centos6.6 64位版本(其他版本后续安装命令可能不同),具体步骤参照腾讯云官方文档。&lt;/li&gt;
&lt;li&gt;本机电脑安装Xshell,Xftp,用于远程连接服务器，方便操作。服务器需开放22端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;安装JDK1-8&quot;&gt;&lt;a href=&quot;#安装JDK1-8&quot; class=&quot;headerlink&quot; title=&quot;安装JDK1.8&quot;&gt;&lt;/a&gt;安装JDK1.8&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;运行以下命令即可：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[root@VM_18_245_centos ~]# yum search jdk&lt;br&gt;[root@VM_18_245_centos ~]]# yum -y install  java-1.8.0-openjdk*&lt;br&gt;正常显示complete,即安装完成。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://prodigalwang.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://prodigalwang.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
